from typing import (
    Any,
    Callable,
    Generator,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
)
from typing_extensions import Literal

import numpy as np
from numpy import _ScalarLike

_ArrayLike = TypeVar("_ArrayLike", _ExtensionArray, np.ndarray)
_DtypeObj = Union[np.dtype, ExtensionDtype]

class ExtensionDtype:
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: Any) -> bool: ...
    @property
    def na_value(self) -> object: ...
    @property
    def type(self) -> Type: ...
    @property
    def kind(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def names(self) -> Optional[List[str]]: ...
    @classmethod
    def construct_array_type(cls) -> Type[_ExtensionArray]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> ExtensionDtype: ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    @property
    def _is_numeric(self) -> bool: ...
    @property
    def _is_boolean(self) -> bool: ...
    def _get_common_dtype(self, dtypes: List[_DtypeObj]) -> Optional[_DtypeObj]: ...

class _ExtensionArray:
    @classmethod
    def _from_sequence(
        cls, scalars: Sequence[_ScalarLike], dtype: Optional[_DtypeObj] = ..., copy: bool = ...
    ) -> _ExtensionArray: ...
    @classmethod
    def _from_sequence_of_strings(
        cls, strings: Sequence[str], dtype: Optional[_DtypeObj] = ..., copy: bool = ...
    ) -> _ExtensionArray: ...
    @classmethod
    def _from_factorized(cls, values: np.ndarray, original: _ExtensionArray) -> _ExtensionArray: ...
    def __getitem__(self, item: Union[int, slice, np.ndarray]) -> Any: ...
    def __setitem__(self, key: Union[int, slice, np.ndarray], value: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Generator[Any, None, None]: ...
    # The next two functions are complaining that we're changing the return type of the base class
    # Which Pandas does. Instead of bool, it returns an array of bools
    # So squelch those warnings
    def __eq__(self, other: Any) -> _ArrayLike: ...  # type: ignore
    def __ne__(self, other: Any) -> _ArrayLike: ...  # type: ignore
    def to_numpy(
        self,
        dtype: Optional[_DtypeObj] = ...,
        copy: bool = ...,
        na_value: Optional[Any] = ...,
    ) -> np.ndarray: ...
    @property
    def dtype(self) -> _DtypeObj: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def size(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    def astype(self, dtype: Union[str, _DtypeObj], copy: bool = ...) -> np.ndarray: ...
    def isna(self) -> _ArrayLike: ...
    def _values_for_argsort(self) -> np.ndarray: ...
    def argsort(
        self, ascending: bool = ..., kind: str = ..., *args: Any, **kwargs: Any
    ) -> np.ndarray: ...
    def argmin(self) -> int: ...
    def argmax(self) -> int: ...
    def fillna(
        self,
        value: Union[_ScalarLike, _ArrayLike] = ...,
        method: Optional[Literal["backfill", "bfill", "pad", "ffill"]] = ...,
        limit: Optional[int] = ...,
    ) -> _ExtensionArray: ...
    def dropna(self) -> _ExtensionArray: ...
    def shift(self, periods: int = ..., fill_value: object = ...) -> _ExtensionArray: ...
    def unique(self) -> _ExtensionArray: ...
    def searchsorted(
        self,
        value: _ArrayLike,
        side: Optional[Literal["left", "right"]] = ...,
        sorter: Optional[_ArrayLike] = ...,
    ) -> np.ndarray: ...
    def equals(self, other: _ExtensionArray) -> bool: ...
    def _values_for_factorize(self) -> Tuple[np.ndarray, Any]: ...
    def factorize(self, na_sentinel: int = ...) -> Tuple[np.ndarray, _ExtensionArray]: ...
    def repeat(
        self, repeats: Union[int, np.ndarray], axis: Optional[int] = ...
    ) -> _ExtensionArray: ...
    def take(
        self, indices: Sequence[int], allow_fill: bool = ..., fill_value: Any = ...
    ) -> _ExtensionArray: ...
    def copy(self) -> _ExtensionArray: ...
    def view(self, dtype: _DtypeObj = ...) -> _ArrayLike: ...
    def __repr__(self) -> str: ...
    def _formatter(self, boxed: bool = ...) -> Callable[[Any], Optional[str]]: ...
    def ravel(self, order: Optional[Literal["C", "F", "A", "K"]] = ...) -> _ExtensionArray: ...
    @classmethod
    def _concat_same_type(cls, to_concat: Sequence[_ExtensionArray]) -> _ExtensionArray: ...
    def _reduce(self, name: str, skipna: bool = ..., **kwargs: Any) -> _ScalarLike: ...
    def __hash__(self) -> int: ...
