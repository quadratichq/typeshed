from typing import Any, Generator, Iterable, Optional, Sequence, Tuple, Type, TypeVar, Union

import numpy as np
from numpy import _ScalarLike

from ..arrays.base import ExtensionArray, ExtensionOpsMixin
from ..dtypes.base import ExtensionDtype, _ArrayLike, _DtypeObj
from ..series import Series

_BaseMaskedArrayT = TypeVar("_BaseMaskedArrayT", bound=BaseMaskedArray)

class BaseMaskedDtype(ExtensionDtype):
    @property
    def numpy_dtype(self) -> np.dtype: ...
    @classmethod
    def construct_array_type(cls) -> Type[BaseMaskedArray]: ...

class BaseMaskedArray(ExtensionArray, ExtensionOpsMixin):
    def __init__(self, values: np.ndarray, mask: np.ndarray, copy: bool = ...) -> None: ...
    @property
    def dtype(self) -> BaseMaskedDtype: ...
    def _coerce_to_array(self, values: Any) -> Tuple[np.ndarray, np.ndarray]: ...
    def __setitem__(self, key: Union[int, slice, np.ndarray], value: Any) -> None: ...
    def __iter__(self) -> Generator[Any, None, None]: ...
    def __len__(self) -> int: ...
    def __invert__(self: _BaseMaskedArrayT) -> _BaseMaskedArrayT: ...
    def to_numpy(
        self, dtype: Optional[_DtypeObj] = ..., copy: bool = ..., na_value: _ScalarLike = ...
    ) -> np.ndarray: ...
    def __array__(self, dtype: _DtypeObj = ...) -> np.ndarray: ...
    def __arrow_array__(self, type: Optional[Any] = ...) -> Any: ...  # pyarrow.array: ...
    @property
    def _hasna(self) -> bool: ...
    def isna(self) -> _ArrayLike: ...
    @property
    def _na_value(self) -> Any: ...
    @property
    def nbytes(self) -> int: ...
    @classmethod
    def _concat_same_type(
        cls: Type[_BaseMaskedArrayT], to_concat: Iterable
    ) -> _BaseMaskedArrayT: ...
    def take(
        self: _BaseMaskedArrayT,
        indexer: Sequence,
        allow_fill: bool = ...,
        fill_value: Optional[_ScalarLike] = ...,
    ) -> _BaseMaskedArrayT: ...
    def copy(self: _BaseMaskedArrayT) -> _BaseMaskedArrayT: ...
    def factorize(self, na_sentinel: int = ...) -> Tuple[np.ndarray, ExtensionArray]: ...
    def value_counts(self, dropna: bool = ...) -> Series: ...
    def _reduce(self, name: str, skipna: bool = ..., **kwargs: Any) -> _ScalarLike: ...
