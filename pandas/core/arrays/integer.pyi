from typing import Any, Callable, List, Optional, Sequence, Type, Union, Tuple
from typing_extensions import Literal
import numpy as np
from numpy import _ScalarLike

from ..dtypes.base import _ArrayLike, _DtypeObj
from .masked import BaseMaskedArray, BaseMaskedDtype

class _IntegerDtype(BaseMaskedDtype):
    def __repr__(self) -> str: ...
    def is_signed_integer(self) -> bool: ...
    def is_unsigned_integer(self) -> bool: ...
    @property
    def _is_numeric(self) -> bool: ...
    def numpy_dtype(self) -> np.dtype: ...
    def kind(self) -> str: ...
    def itemsize(self) -> int: ...
    @classmethod
    def construct_array_type(cls) -> Type[IntegerArray]: ...
    def _get_common_dtype(self, dtypes: List[_DtypeObj]) -> Optional[_DtypeObj]: ...
    def __from_arrow__(
        self,
        array: Any,  # Union[pyarrow.Array, pyarrow.ChunkedArray]
    ) -> IntegerArray: ...

class IntegerArray(BaseMaskedArray):
    def dtype(self) -> _IntegerDtype: ...
    def __init__(self, values: np.ndarray, mask: np.ndarray, copy: bool = ...) -> None: ...
    @classmethod
    def _from_sequence(
        cls, scalars: Sequence[_ScalarLike], dtype: Optional[_DtypeObj] = ..., copy: bool = ...
    ) -> IntegerArray: ...
    @classmethod
    def _from_sequence_of_strings(
        cls, strings: Sequence[str], dtype: Optional[_DtypeObj] = ..., copy: bool = ...
    ) -> IntegerArray: ...
    def __array_ufunc__(
        self,
        ufunc: Callable[..., Any],
        method: Literal["reduce", "accumulate", "reduceat", "outer", "at", "__call__"],
        *inputs: Any,
        **kwargs: Any,
    ) -> Any: ...
    def _coerce_to_array(self, value: Any) -> Tuple[np.ndarray, np.ndarray]: ...
    def astype(self, dtype: Union[str, _DtypeObj], copy: bool = ...) -> _ArrayLike: ...
    def _values_for_argsort(self) -> np.ndarray: ...
    @classmethod
    def _create_comparison_method(cls, op: Callable[..., Any]) -> Callable[..., bool]: ...
    def sum(self, skipna: bool = ..., min_count: int = ..., **kwargs: Any) -> _IntegerDtype: ...
    def _maybe_mask_result(
        self,
        result: _ArrayLike,
        mask: _ArrayLike,
        other: Union[_ScalarLike, _ArrayLike],
        op_name: str,
    ) -> Callable[[Any, Any], IntegerArray]: ...
    @classmethod
    def _create_arithmetic_method(
        cls, op: Callable[..., Any]
    ) -> Callable[[Any, Any], IntegerArray]: ...

class Int8Dtype(_IntegerDtype): ...
class Int16Dtype(_IntegerDtype): ...
class Int32Dtype(_IntegerDtype): ...
class Int64Dtype(_IntegerDtype): ...
class UInt8Dtype(_IntegerDtype): ...
class UInt16Dtype(_IntegerDtype): ...
class UInt32Dtype(_IntegerDtype): ...
class UInt64Dtype(_IntegerDtype): ...
